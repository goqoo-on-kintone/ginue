import fs from 'fs'
import path from 'path'
// TODO: cloneDeepだけならJSON.stringify()で十分なのでlodashやめる
import { cloneDeep } from 'lodash'
import mkdirp from 'mkdirp'
import prettier from 'prettier'
import { prettyln, trim, createDirPath, createFilePath } from './util'
import { fetchKintoneInfo, downloadFile } from './client'
import { convertAppIdToName } from './converter'
import type { ViewForResponse, AppRightEntityForResponse } from '@kintone/rest-api-client/lib/client/types/app'
import type { OneOf } from '@kintone/rest-api-client/lib/KintoneFields/types/property'
import type { AppCustomize, Opts, Ktn } from './types'

// .prettierrcがあればそれに沿ってフォーマット
const prettierOptions = prettier.resolveConfig.sync(process.cwd()) || {}
// parserを指定しないと警告が出るのでその対策
prettierOptions.parser = prettierOptions.parser || 'babel'

const compare = (i: number | string, j: number | string) => {
  if (i < j) {
    return -1
  } else if (i > j) {
    return 1
  }
  return 0
}

const cloneSort = (ktn: Ktn, kintoneInfoObj: any) => {
  switch (ktn.command) {
    case 'app/form/fields.json': {
      const keys = Object.keys(kintoneInfoObj.properties)
      keys.sort()
      const properties = keys.reduce<Record<string, OneOf>>((obj, key) => {
        const property = cloneDeep(kintoneInfoObj.properties[key]) as OneOf
        if ('lookup' in property) {
          property.lookup.fieldMappings.sort((i, j) => compare(i.field, j.field))
        }
        if (property.type === 'DROP_DOWN') {
          const options = Object.entries(cloneDeep(property.options))
          options.sort(([, i], [, j]) => compare(Number(i.index), Number(j.index)))
          property.options = Object.fromEntries(options)
        }
        obj[key] = property
        return obj
      }, {})
      return { properties }
    }
    case 'app/views.json': {
      const _views = kintoneInfoObj.views as Record<string, ViewForResponse>
      const viewEntries = Object.entries(cloneDeep(_views))
      const indexes = Object.values(_views).map((v) => v.index)
      indexes.sort((i, j) => compare(Number(i), Number(j)))
      const views = indexes.reduce<Record<string, ViewForResponse>>((obj, index) => {
        const [key, value] = viewEntries.find(([, value]) => value.index === index)!
        obj[key] = value
        return obj
      }, {})
      return { views }
    }
    case 'field/acl.json': {
      const rights = cloneDeep(kintoneInfoObj.rights as AppRightEntityForResponse[])
      rights.sort((i, j) => compare(i.entity.code!, j.entity.code!))
      return { rights }
    }
  }
  return kintoneInfoObj
}

const convertKintoneInfo = (kintoneInfoObj: { revision?: number }, ktn: Ktn, opts: Opts) => {
  let kintoneRevision
  if (kintoneInfoObj.revision) {
    kintoneRevision = prettyln({ revision: kintoneInfoObj.revision })
    delete kintoneInfoObj.revision
  }
  const kintoneInfo = prettyln(cloneSort(ktn, kintoneInfoObj))

  let kintoneInfoAlt
  if (opts.alt) {
    const isConverted = convertAppIdToName(ktn, kintoneInfoObj)
    kintoneInfoAlt = isConverted ? prettyln(cloneSort(ktn, kintoneInfoObj)) : undefined
  }

  return [kintoneInfo, kintoneRevision, kintoneInfoAlt]
}

const saveKintoneInfo = async (filePath: string, kintoneInfo: string) => {
  const extension = path.extname(filePath)
  if (extension === '.js') {
    kintoneInfo = prettier.format(
      trim(`
// Generated by ginue
module.exports = ${kintoneInfo}
`),
      prettierOptions
    )
  }
  fs.writeFileSync(filePath, kintoneInfo)
}

const downloadCustomizeFiles = async (kintoneInfo: string, ktn: Ktn, opts: Opts) => {
  const customizeInfo = JSON.parse(kintoneInfo) as AppCustomize
  const fileInfos = (['desktop', 'mobile'] as const).flatMap((target) =>
    [customizeInfo[target].js, customizeInfo[target].css].flatMap((infos) =>
      infos.filter((info) => info.type === 'FILE').map((info) => ({ ...info.file, target }))
    )
  )
  const dirPath = `${createDirPath(ktn, opts)}/customize`
  for (const jsFileInfo of fileInfos) {
    const { fileKey, name, target } = jsFileInfo
    const jsFile = await downloadFile(ktn, fileKey)
    const jsFilePath = `${dirPath}/${target}/${name}`
    mkdirp.sync(path.dirname(jsFilePath))
    fs.writeFileSync(jsFilePath, jsFile)
    console.info(jsFilePath)
  }
}

export const ginuePull = async (ktn: Ktn, opts: Opts) => {
  if (!ktn.methods?.includes('GET')) {
    return
  }
  const kintoneInfoObj = await fetchKintoneInfo(ktn)
  const [kintoneInfo, kintoneRevision, kintoneInfoAlt] = convertKintoneInfo(kintoneInfoObj, ktn, opts)
  const filePath = createFilePath(ktn, opts)
  console.info(filePath)
  saveKintoneInfo(filePath, kintoneInfo!)
  if (kintoneRevision) {
    // TODO: 無駄に何回も上書保存するので、フラグを持たせて1回だけにしたい
    const revisionFilePath = createFilePath(ktn, opts, 'revision.json')
    saveKintoneInfo(revisionFilePath, kintoneRevision)
  }
  if (kintoneInfoAlt) {
    const altFilePath = filePath.replace('.js', '-alt.js') // (.json|.js) どっちにも対応するhack。。。
    console.info(altFilePath)
    saveKintoneInfo(altFilePath, kintoneInfoAlt)
  }
  if (ktn.command === 'app/customize.json' && opts.downloadJs) {
    await downloadCustomizeFiles(kintoneInfo!, ktn, opts)
  }
}
